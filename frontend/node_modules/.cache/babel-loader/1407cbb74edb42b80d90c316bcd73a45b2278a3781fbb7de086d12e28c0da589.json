{"ast":null,"code":"'use client';\n\nimport { useState, useCallback } from 'react';\nimport { getAllCheckedNodes } from './get-all-checked-nodes/get-all-checked-nodes.mjs';\nimport { getChildrenNodesValues, getAllChildrenNodes } from './get-children-nodes-values/get-children-nodes-values.mjs';\nimport { memoizedIsNodeChecked } from './is-node-checked/is-node-checked.mjs';\nimport { memoizedIsNodeIndeterminate } from './is-node-indeterminate/is-node-indeterminate.mjs';\nfunction getInitialTreeExpandedState(initialState, data, value) {\n  let acc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  data.forEach(node => {\n    acc[node.value] = node.value in initialState ? initialState[node.value] : node.value === value;\n    if (Array.isArray(node.children)) {\n      getInitialTreeExpandedState(initialState, node.children, value, acc);\n    }\n  });\n  return acc;\n}\nfunction getTreeExpandedState(data, expandedNodesValues) {\n  const state = getInitialTreeExpandedState({}, data, []);\n  if (expandedNodesValues === \"*\") {\n    return Object.keys(state).reduce((acc, key) => ({\n      ...acc,\n      [key]: true\n    }), {});\n  }\n  expandedNodesValues.forEach(node => {\n    state[node] = true;\n  });\n  return state;\n}\nfunction getInitialCheckedState(initialState, data) {\n  const acc = [];\n  initialState.forEach(node => acc.push(...getChildrenNodesValues(node, data)));\n  return Array.from(new Set(acc));\n}\nfunction useTree() {\n  let {\n    initialSelectedState = [],\n    initialCheckedState = [],\n    initialExpandedState = {},\n    multiple = false,\n    onNodeCollapse,\n    onNodeExpand\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [data, setData] = useState([]);\n  const [expandedState, setExpandedState] = useState(initialExpandedState);\n  const [selectedState, setSelectedState] = useState(initialSelectedState);\n  const [checkedState, setCheckedState] = useState(initialCheckedState);\n  const [anchorNode, setAnchorNode] = useState(null);\n  const [hoveredNode, setHoveredNode] = useState(null);\n  const initialize = useCallback(_data => {\n    setExpandedState(current => getInitialTreeExpandedState(current, _data, selectedState));\n    setCheckedState(current => getInitialCheckedState(current, _data));\n    setData(_data);\n  }, [selectedState, checkedState]);\n  const toggleExpanded = useCallback(value => {\n    setExpandedState(current => {\n      const nextState = {\n        ...current,\n        [value]: !current[value]\n      };\n      nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value);\n      return nextState;\n    });\n  }, [onNodeCollapse, onNodeExpand]);\n  const collapse = useCallback(value => {\n    setExpandedState(current => {\n      if (current[value] !== false) {\n        onNodeCollapse?.(value);\n      }\n      return {\n        ...current,\n        [value]: false\n      };\n    });\n  }, [onNodeCollapse]);\n  const expand = useCallback(value => {\n    setExpandedState(current => {\n      if (current[value] !== true) {\n        onNodeExpand?.(value);\n      }\n      return {\n        ...current,\n        [value]: true\n      };\n    });\n  }, [onNodeExpand]);\n  const expandAllNodes = useCallback(() => {\n    setExpandedState(current => {\n      const next = {\n        ...current\n      };\n      Object.keys(next).forEach(key => {\n        next[key] = true;\n      });\n      return next;\n    });\n  }, []);\n  const collapseAllNodes = useCallback(() => {\n    setExpandedState(current => {\n      const next = {\n        ...current\n      };\n      Object.keys(next).forEach(key => {\n        next[key] = false;\n      });\n      return next;\n    });\n  }, []);\n  const toggleSelected = useCallback(value => setSelectedState(current => {\n    if (!multiple) {\n      if (current.includes(value)) {\n        setAnchorNode(null);\n        return [];\n      }\n      setAnchorNode(value);\n      return [value];\n    }\n    if (current.includes(value)) {\n      setAnchorNode(null);\n      return current.filter(item => item !== value);\n    }\n    setAnchorNode(value);\n    return [...current, value];\n  }), []);\n  const select = useCallback(value => {\n    setAnchorNode(value);\n    setSelectedState(current => multiple ? current.includes(value) ? current : [...current, value] : [value]);\n  }, []);\n  const deselect = useCallback(value => {\n    anchorNode === value && setAnchorNode(null);\n    setSelectedState(current => current.filter(item => item !== value));\n  }, []);\n  const clearSelected = useCallback(() => {\n    setSelectedState([]);\n    setAnchorNode(null);\n  }, []);\n  const checkNode = useCallback(value => {\n    const checkedNodes = getChildrenNodesValues(value, data);\n    setCheckedState(current => Array.from(/* @__PURE__ */new Set([...current, ...checkedNodes])));\n  }, [data]);\n  const uncheckNode = useCallback(value => {\n    const checkedNodes = getChildrenNodesValues(value, data);\n    setCheckedState(current => current.filter(item => !checkedNodes.includes(item)));\n  }, [data]);\n  const checkAllNodes = useCallback(() => {\n    setCheckedState(() => getAllChildrenNodes(data));\n  }, [data]);\n  const uncheckAllNodes = useCallback(() => {\n    setCheckedState([]);\n  }, []);\n  const getCheckedNodes = () => getAllCheckedNodes(data, checkedState).result;\n  const isNodeChecked = value => memoizedIsNodeChecked(value, data, checkedState);\n  const isNodeIndeterminate = value => memoizedIsNodeIndeterminate(value, data, checkedState);\n  return {\n    multiple,\n    expandedState,\n    selectedState,\n    checkedState,\n    anchorNode,\n    initialize,\n    toggleExpanded,\n    collapse,\n    expand,\n    expandAllNodes,\n    collapseAllNodes,\n    setExpandedState,\n    checkNode,\n    uncheckNode,\n    checkAllNodes,\n    uncheckAllNodes,\n    setCheckedState,\n    toggleSelected,\n    select,\n    deselect,\n    clearSelected,\n    setSelectedState,\n    hoveredNode,\n    setHoveredNode,\n    getCheckedNodes,\n    isNodeChecked,\n    isNodeIndeterminate\n  };\n}\nexport { getTreeExpandedState, useTree };","map":{"version":3,"names":["getInitialTreeExpandedState","initialState","data","value","acc","arguments","length","undefined","forEach","node","Array","isArray","children","getTreeExpandedState","expandedNodesValues","state","Object","keys","reduce","key","getInitialCheckedState","push","getChildrenNodesValues","from","Set","useTree","initialSelectedState","initialCheckedState","initialExpandedState","multiple","onNodeCollapse","onNodeExpand","setData","useState","expandedState","setExpandedState","selectedState","setSelectedState","checkedState","setCheckedState","anchorNode","setAnchorNode","hoveredNode","setHoveredNode","initialize","useCallback","_data","current","toggleExpanded","nextState","collapse","expand","expandAllNodes","next","collapseAllNodes","toggleSelected","includes","filter","item","select","deselect","clearSelected","checkNode","checkedNodes","uncheckNode","checkAllNodes","getAllChildrenNodes","uncheckAllNodes","getCheckedNodes","getAllCheckedNodes","result","isNodeChecked","memoizedIsNodeChecked","isNodeIndeterminate","memoizedIsNodeIndeterminate"],"sources":["C:\\Users\\josemontedeoca\\rrhh-system\\frontend\\node_modules\\@mantine\\core\\src\\components\\Tree\\use-tree.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport {\n  CheckedNodeStatus,\n  getAllCheckedNodes,\n} from './get-all-checked-nodes/get-all-checked-nodes';\nimport {\n  getAllChildrenNodes,\n  getChildrenNodesValues,\n} from './get-children-nodes-values/get-children-nodes-values';\nimport { memoizedIsNodeChecked } from './is-node-checked/is-node-checked';\nimport { memoizedIsNodeIndeterminate } from './is-node-indeterminate/is-node-indeterminate';\nimport type { TreeNodeData } from './Tree';\n\nexport type TreeExpandedState = Record<string, boolean>;\n\nfunction getInitialTreeExpandedState(\n  initialState: TreeExpandedState,\n  data: TreeNodeData[],\n  value: string | string[] | undefined,\n  acc: TreeExpandedState = {}\n) {\n  data.forEach((node) => {\n    acc[node.value] = node.value in initialState ? initialState[node.value] : node.value === value;\n\n    if (Array.isArray(node.children)) {\n      getInitialTreeExpandedState(initialState, node.children, value, acc);\n    }\n  });\n\n  return acc;\n}\n\nexport function getTreeExpandedState(data: TreeNodeData[], expandedNodesValues: string[] | '*') {\n  const state = getInitialTreeExpandedState({}, data, []);\n\n  if (expandedNodesValues === '*') {\n    return Object.keys(state).reduce((acc, key) => ({ ...acc, [key]: true }), {});\n  }\n\n  expandedNodesValues.forEach((node) => {\n    state[node] = true;\n  });\n\n  return state;\n}\n\nfunction getInitialCheckedState(initialState: string[], data: TreeNodeData[]) {\n  const acc: string[] = [];\n\n  initialState.forEach((node) => acc.push(...getChildrenNodesValues(node, data)));\n\n  return Array.from(new Set(acc));\n}\n\nexport interface UseTreeInput {\n  /** Initial expanded state of all nodes */\n  initialExpandedState?: TreeExpandedState;\n\n  /** Initial selected state of nodes */\n  initialSelectedState?: string[];\n\n  /** Initial checked state of nodes */\n  initialCheckedState?: string[];\n\n  /** Determines whether multiple node can be selected at a time */\n  multiple?: boolean;\n\n  /** Called with the node value when it is expanded */\n  onNodeExpand?: (value: string) => void;\n\n  /** Called with the node value when it is collapsed */\n  onNodeCollapse?: (value: string) => void;\n}\n\nexport interface UseTreeReturnType {\n  /** Determines whether multiple node can be selected at a time */\n  multiple: boolean;\n\n  /** A record of `node.value` and boolean values that represent nodes expanded state */\n  expandedState: TreeExpandedState;\n\n  /** An array of selected nodes values */\n  selectedState: string[];\n\n  /** An array of checked nodes values */\n  checkedState: string[];\n\n  /** A value of the node that was last clicked\n   * Anchor node is used to determine range of selected nodes for multiple selection\n   */\n  anchorNode: string | null;\n\n  /** Initializes tree state based on provided data, called automatically by the Tree component */\n  initialize: (data: TreeNodeData[]) => void;\n\n  /** Toggles expanded state of the node with provided value */\n  toggleExpanded: (value: string) => void;\n\n  /** Collapses node with provided value */\n  collapse: (value: string) => void;\n\n  /** Expands node with provided value */\n  expand: (value: string) => void;\n\n  /** Expands all nodes */\n  expandAllNodes: () => void;\n\n  /** Collapses all nodes */\n  collapseAllNodes: () => void;\n\n  /** Sets expanded state */\n  setExpandedState: React.Dispatch<React.SetStateAction<TreeExpandedState>>;\n\n  /** Toggles selected state of the node with provided value */\n  toggleSelected: (value: string) => void;\n\n  /** Selects node with provided value */\n  select: (value: string) => void;\n\n  /** Deselects node with provided value */\n  deselect: (value: string) => void;\n\n  /** Clears selected state */\n  clearSelected: () => void;\n\n  /** Sets selected state */\n  setSelectedState: React.Dispatch<React.SetStateAction<string[]>>;\n\n  /** A value of the node that is currently hovered */\n  hoveredNode: string | null;\n\n  /** Sets hovered node */\n  setHoveredNode: React.Dispatch<React.SetStateAction<string | null>>;\n\n  /** Checks node with provided value */\n  checkNode: (value: string) => void;\n\n  /** Unchecks node with provided value */\n  uncheckNode: (value: string) => void;\n\n  /** Checks all nodes */\n  checkAllNodes: () => void;\n\n  /** Unchecks all nodes */\n  uncheckAllNodes: () => void;\n\n  /** Sets checked state */\n  setCheckedState: React.Dispatch<React.SetStateAction<string[]>>;\n\n  /** Returns all checked nodes with status */\n  getCheckedNodes: () => CheckedNodeStatus[];\n\n  /** Returns `true` if node with provided value is checked */\n  isNodeChecked: (value: string) => boolean;\n\n  /** Returns `true` if node with provided value is indeterminate */\n  isNodeIndeterminate: (value: string) => boolean;\n}\n\nexport function useTree({\n  initialSelectedState = [],\n  initialCheckedState = [],\n  initialExpandedState = {},\n  multiple = false,\n  onNodeCollapse,\n  onNodeExpand,\n}: UseTreeInput = {}): UseTreeReturnType {\n  const [data, setData] = useState<TreeNodeData[]>([]);\n  const [expandedState, setExpandedState] = useState(initialExpandedState);\n  const [selectedState, setSelectedState] = useState(initialSelectedState);\n  const [checkedState, setCheckedState] = useState(initialCheckedState);\n  const [anchorNode, setAnchorNode] = useState<string | null>(null);\n  const [hoveredNode, setHoveredNode] = useState<string | null>(null);\n\n  const initialize = useCallback(\n    (_data: TreeNodeData[]) => {\n      setExpandedState((current) => getInitialTreeExpandedState(current, _data, selectedState));\n      setCheckedState((current) => getInitialCheckedState(current, _data));\n      setData(_data);\n    },\n    [selectedState, checkedState]\n  );\n\n  const toggleExpanded = useCallback(\n    (value: string) => {\n      setExpandedState((current) => {\n        const nextState = { ...current, [value]: !current[value] };\n        nextState[value] ? onNodeExpand?.(value) : onNodeCollapse?.(value);\n        return nextState;\n      });\n    },\n    [onNodeCollapse, onNodeExpand]\n  );\n\n  const collapse = useCallback(\n    (value: string) => {\n      setExpandedState((current) => {\n        if (current[value] !== false) {\n          onNodeCollapse?.(value);\n        }\n\n        return { ...current, [value]: false };\n      });\n    },\n    [onNodeCollapse]\n  );\n\n  const expand = useCallback(\n    (value: string) => {\n      setExpandedState((current) => {\n        if (current[value] !== true) {\n          onNodeExpand?.(value);\n        }\n\n        return { ...current, [value]: true };\n      });\n    },\n    [onNodeExpand]\n  );\n\n  const expandAllNodes = useCallback(() => {\n    setExpandedState((current) => {\n      const next = { ...current };\n      Object.keys(next).forEach((key) => {\n        next[key] = true;\n      });\n\n      return next;\n    });\n  }, []);\n\n  const collapseAllNodes = useCallback(() => {\n    setExpandedState((current) => {\n      const next = { ...current };\n      Object.keys(next).forEach((key) => {\n        next[key] = false;\n      });\n\n      return next;\n    });\n  }, []);\n\n  const toggleSelected = useCallback(\n    (value: string) =>\n      setSelectedState((current) => {\n        if (!multiple) {\n          if (current.includes(value)) {\n            setAnchorNode(null);\n            return [];\n          }\n\n          setAnchorNode(value);\n          return [value];\n        }\n\n        if (current.includes(value)) {\n          setAnchorNode(null);\n          return current.filter((item) => item !== value);\n        }\n\n        setAnchorNode(value);\n\n        return [...current, value];\n      }),\n    []\n  );\n\n  const select = useCallback((value: string) => {\n    setAnchorNode(value);\n    setSelectedState((current) =>\n      multiple ? (current.includes(value) ? current : [...current, value]) : [value]\n    );\n  }, []);\n\n  const deselect = useCallback((value: string) => {\n    anchorNode === value && setAnchorNode(null);\n    setSelectedState((current) => current.filter((item) => item !== value));\n  }, []);\n\n  const clearSelected = useCallback(() => {\n    setSelectedState([]);\n    setAnchorNode(null);\n  }, []);\n\n  const checkNode = useCallback(\n    (value: string) => {\n      const checkedNodes = getChildrenNodesValues(value, data);\n      setCheckedState((current) => Array.from(new Set([...current, ...checkedNodes])));\n    },\n    [data]\n  );\n\n  const uncheckNode = useCallback(\n    (value: string) => {\n      const checkedNodes = getChildrenNodesValues(value, data);\n      setCheckedState((current) => current.filter((item) => !checkedNodes.includes(item)));\n    },\n    [data]\n  );\n\n  const checkAllNodes = useCallback(() => {\n    setCheckedState(() => getAllChildrenNodes(data));\n  }, [data]);\n\n  const uncheckAllNodes = useCallback(() => {\n    setCheckedState([]);\n  }, []);\n\n  const getCheckedNodes = () => getAllCheckedNodes(data, checkedState).result;\n  const isNodeChecked = (value: string) => memoizedIsNodeChecked(value, data, checkedState);\n  const isNodeIndeterminate = (value: string) =>\n    memoizedIsNodeIndeterminate(value, data, checkedState);\n\n  return {\n    multiple,\n    expandedState,\n    selectedState,\n    checkedState,\n    anchorNode,\n    initialize,\n\n    toggleExpanded,\n    collapse,\n    expand,\n    expandAllNodes,\n    collapseAllNodes,\n    setExpandedState,\n\n    checkNode,\n    uncheckNode,\n    checkAllNodes,\n    uncheckAllNodes,\n    setCheckedState,\n\n    toggleSelected,\n    select,\n    deselect,\n    clearSelected,\n    setSelectedState,\n\n    hoveredNode,\n    setHoveredNode,\n    getCheckedNodes,\n    isNodeChecked,\n    isNodeIndeterminate,\n  };\n}\n\nexport type TreeController = ReturnType<typeof useTree>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}